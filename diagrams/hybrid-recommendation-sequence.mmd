%% Hybrid Recommendation System - Sequence Diagram
%% Render: Mermaid Live Editor (https://mermaid.live/), VS Code Mermaid extension, or GitHub/GitLab
%% Export: PNG, SVG for FYP report

sequenceDiagram
    actor User
    participant Controller as Controller<br/>(HomeController /<br/>RecommendationController)
    participant RecSvc as RecommendationService
    participant Cache
    participant OrderItem as OrderItem + Order
    participant UBI as UserBookInteraction
    participant UserModel as User<br/>(wishlistBooks)
    participant Book

    %% Request Recommendations
    User->>+Controller: GET /api/recommendations/me?limit=12
    Controller->>+RecSvc: recommendForUser(user, limit)

    %% Cache Check
    RecSvc->>Cache: get(reco:user:{id}:v1:{limit})

    alt Cache Hit
        Cache-->>RecSvc: cached Collection&lt;Book&gt;
    else Cache Miss
        Cache-->>RecSvc: null
        RecSvc->>RecSvc: generateRecommendations(user, limit)

        rect rgb(230, 245, 255)
            Note over RecSvc,Book: Content-Based Filtering
            RecSvc->>RecSvc: contentBasedScores(user)
            RecSvc->>OrderItem: getPurchasedBookIds(user)<br/>[join orders, status=completed]
            OrderItem-->>RecSvc: purchasedBookIds[]
            RecSvc->>UserModel: wishlistBooks()
            UserModel-->>RecSvc: wishlistBookIds[]
            RecSvc->>UBI: where(user_id, action in [view,click,cart,wishlist])
            UBI-->>RecSvc: interactions (book_id => weight×count)
            RecSvc->>Book: whereIn(id, interestIds)<br/>with genre, tropes
            Book-->>RecSvc: baseBooks
            Note right of RecSvc: Build genre/trope/author weights<br/>from purchased (5.0), wishlist (3.0),<br/>interactions (capped 2.0)
            RecSvc->>Book: whereNotIn(purchased), stock>0
            Book-->>RecSvc: candidates
            RecSvc->>RecSvc: score each candidate<br/>(genre + trope + author + popularity)
            RecSvc->>RecSvc: normalizeVector(scores)
            RecSvc-->>RecSvc: contentScores[book_id => 0..1]
        end

        rect rgb(230, 255, 230)
            Note over RecSvc,Book: Collaborative Filtering
            RecSvc->>RecSvc: collaborativeScores(user)
            RecSvc->>OrderItem: getPurchasedBookIds(user)
            OrderItem-->>RecSvc: purchasedBookIds[]
            RecSvc->>OrderItem: find peer users<br/>(users who bought same books)
            OrderItem-->>RecSvc: peerUserIds[]
            RecSvc->>OrderItem: books purchased by peers<br/>(not in user's purchased)<br/>group by book_id, count, limit 200
            OrderItem-->>RecSvc: rows (book_id, cnt)
            RecSvc->>RecSvc: normalizeVector(scores)
            RecSvc-->>RecSvc: collabScores[book_id => 0..1]
        end

        rect rgb(255, 250, 230)
            Note over RecSvc,Book: Hybrid Fusion
            alt Cold Start (both contentScores and collabScores empty)
                RecSvc->>RecSvc: fallbackRecommendations(limit)
                RecSvc->>Book: where(stock>0)<br/>orderBy(reviews_count, created_at)<br/>take(limit)
                Book-->>RecSvc: popular books
            else Has Scores
                Note right of RecSvc: finalScore = 0.6 × contentScore<br/>+ 0.4 × collabScore
                RecSvc->>Book: whereIn(id, scoredIds)<br/>with genre, tropes
                Book-->>RecSvc: books
                RecSvc->>RecSvc: sortByDesc(score), take(limit)
            end
            RecSvc->>Cache: put(result, 30 min)
        end
    end

    RecSvc-->>-Controller: Collection&lt;Book&gt;
    Controller-->>-User: JSON { data: books[] }
